在程式中宣告變數後有以下三個性質：變數名稱、變數位置、變數值(即便沒初始化也有值)，然而在 C 語言中提供了一種特別的物件-指標。除了前面提到的基本型別與組合型別外，還多了 void 與函數指標。與變數不同，指標是佔據了一段位置而已，且不論是哪種基本型別的指標，其所占用的記憶體都是 4 bytes(x86)/8 bytes(x64)。

## 1. 基本型別的宣告與使用
宣告一個指標如同宣告變數一樣，要給定型別與名稱，並使用 * (indirect operator)告訴編譯器這個變數是指標。指標的宣告方式有以下兩種
```C
int *b, *c;  //b, c都是指標
int* e, f;   //e 是指標，f 是變數
int n = 1;
int *b;
b = &n;
*b = 20;
printf("%d, %d\n", *b, n);
```
通常在宣告時會使用第一種，第二種宣告方式會讓人誤以為兩者都是指標。而指標無法直接賦值(除了賦予空指標常數)，只能直接將其指向某一變數，使用 &(address of)算符。當一指標指向某變數後，指標跟該變數就會綁在一起，故改變其中一個另一個也會跟改變。故要改變指標的值，必須先指向一變數才能改變。
而指標對於型別的要求較嚴格，只能指向相同型別的變數，一般的變數並無嚴格限制，但是會失去精度。
```C
int *b;
int c = 10;
float pi = 3.14f;
b = &c;  //OK
b = &d;  //會報錯
c = pi;
```

## 2. 指標與結構
結構內可包含許多基本型別，故在這分結構內的指標與結構指標討論
### 結構/聯合內的指標
```C
n = 1;
struct p 
{
    int *a;
}test;
test.a = &n;
printf("%d, %d\n", *test.a, n);
*(test.a) = 20;
printf("%d, %d\n", *(test.a), n);
```
一般的指標是先取了該變數，再在前面加上算符，故結構內取指標的方式為 1. 先取出結構內的變數。 2. 在前面加上算符。如 `*(test.a)` 所示。而聯合的取法與結構完全一樣，故不再多說，下列也忽略聯合。

### 指標結構
指標也可以指向一個結構，若有一個指向結構的指標 A 與一個結構 B，則需先將 A 指向 B 後才能取用內部成員
```C
struct p
{
    char a;
}*test1, test2;
test2.a = 10;
test1 = &test2;
printf("%d\n", (*test1).a);
```
在取用指向結構的成員時與取用結構內指標寫法類似，容易搞混，故在 C/C++ 中使用 -> 來取代原本的算符，整理如下  
`* (test.a) = * test.a --> a 是結構 test 內的成員，且為指標類別`  
`(* test).a = test->a --> a 是指向結構的指標指向 test 內的成員`  
這種算符除了可以免於搞混與取用結構內指標外，在可讀性上也增加了不少，例如若是巢狀結構，內部有巢狀指標，最內層為指標變數，原寫成  
(* (* (* a).b).c).d  
則可改寫成  
a->b->c->d  

### 指向結構的指標內有指標變數
綜合上面兩種寫法，若是一個指向結構內的指標中的成員為指標，寫法如下
```C
struct p
{
    int *x;
}*ptr, pp;
int a = 5, b = 10;
pp.x = &a;
ptr = &pp;
printf("%d\n", *(ptr->x));
```

## 3. 泛型指標 void *
當宣告一個基本類別的變數，其占了三個部分：1. 變數名稱，2. 變數位置，3. 變數數值。而每一種基本類別也有指標的型別，相對於變數，指標少了變數數值。而一般的變數可以直接轉型，此種稱為**顯示轉型**，甚至編譯器也會直接幫你轉型，稱為**隱性轉型**，範例如下
```C
int x = (int) 5.5f; // x = 5 (顯示轉換)
int x = 5.5f; // x = 5 (隱示轉換)
```
但是並非所有情況編譯器都會做轉換，例如兩個整數型別相除仍為整數，結果會失去精度。double 轉 float (失去精度) 轉 int (捨去小數，無條件捨去)，int 轉 short int (注意溢位)，故建議要轉型都以顯示轉型為主。  
而相對於變數，多數情況指標轉型必須先轉成泛型指標後再轉成另外一種指標。
![image](pic/void_ptr.jpg)
