在電腦的世界中，所有的數值都是用二進位來表示，不論是整數或是浮點數。若是對於電腦的邏輯運算非常熟練，則在計算效能上會有很大的幫助。在 C 語言中，位元算符共有左移<<、右移>>、& AND、| OR、^ XOR、~ NOT，以下將分別介紹

## 1. 進位制
假設一個數是使用 n 進位，則在該數值中最大的數字為 m < n-1，例如二進位制的數值只有 0 與 1，而十進位則有 0，...，9，16 進位因為超過阿拉伯數字，所以 a 代表 10，b 代表11，...，f 代表 15。而 n 進位中的數值總共有 i 位，則第 j 位的數值 k，則該位數代表的大小為 k* n<sup>(j-1)</sup> (n 的 j-1 次方)。\
例如一 10 進位數字 3456，第二位(最右邊為第一位)數字為 5，則其代表的數值為 5* 10<sup>(2-1)</sup> = 5* 10<sup>1</sup>。一 16 進位數字 fe，第二位數字為 f，則其代表的數值為 15* 16<sup>(2-1)</sup> = 15* 16<sup>1</sup>。一 10 進位數字 001101101，第四位數字為 1，則其代表的數值為 1* 2<sup>(4-1)</sup> = 1* 2<sup>3</sup>。

## 2. 左移與右移算符
若為 n 進位的數值，所有數字往左移一位，則指數 +1，反之則 -1。對於二進位制而言，左移一位即為 * 2，右移一位即為 / 2。此規則僅在整數型別運算成立，**浮點數則不成立**。當一整數使用左/右移運算後，最左/右邊的位元會自動補 0。使用位移運算時最好將該變數設成**無號數**，因為有號數的最高位數放的是正負號。位移後會發生未定義行為(Undefined-Behavior, UB)
```C
unsigned char a = 8;   //0x00001000
a = a << 3;            //0x01000000 = 64
unsigned char b = 127; //0x01111111
b = b >> 3;            //0x01111111 = 63
//可以想成小數點被直接捨去。
```
在編譯器沒有做最佳化的情況下，位移運算會比數值的 * 2 和 /2 還要快，尤其是在運算資源很少的情況下。

## 3. 其餘位元運算
因為電腦中只有 0 和 1，所以常用來當作對和錯的代號，例如 0 當作是錯誤，1 當作是正確，即對應到數學的邏輯關係，但在 C 語言中邏輯判斷有另外的算符。我們可以想像有兩個事件 a, b，若 0 為不成立，1 為成立，以下分別討論四種算符的結果
#### 1. & AND 運算
AND 就是只當兩個事件同時成立時才成立，則只要有一事件為 0 或是兩者皆為 0 即為 0，其餘為 1，故結果如下
|& | a = 0 | a = 1|
| --- | ---: | ---: |
| b = 0 | 0 | 0 |
| b = 1 | 0 | 1 |

#### 2. | OR 運算
OR 就是只當其中一事件就成立，則只要有一事件為 1 或是兩者皆為 1 即為 1，其餘為 0，故結果如下
| OR | a = 0 | a = 1|
| --- | ---: | ---: |
| b = 0 | 0 | 1 |
| b = 1 | 1 | 1 |

可用此性質將某變數的第 n 的位元設成 1 ```void SetNthBit(unsigned char x, unsigned char n) {x |= (1 << n);}```，此種寫法只會將第 n 位的位元設為 1。\
```
SetNthBit(1, 5); 
/*
  00000001
| 00010000
-----------
  00010001
*/
```
若是要將某一區段的位元設為 1，則可另外設個變數與該變數做 or 運算 
```C
unsigned char x = 128, n = 7;  //   n = 0x00000111
x |= (n << 3);  將 x 的第 4~6 為設成 1
/*
  01000000
| 00111000
-----------
  01111000
*/
```

#### 3. ^ XOR 運算
XOR 就是只當其中一事件則成立，但非兩者同時成立，故當兩事件同時為 0 或同時為 1，即為 0，其餘為 1，故結果如下
| ^ | a = 0 | a = 1|
| --- | ---: | ---: |
| b = 0 | 0 | 1 |
| b = 1 | 1 | 0 |

可利用此性質將某變數的第 n 的位元反轉(1 變 0，0 變 1)```void ToggleNthBit(unsigned char x, unsigned char n) {x ^= (1 << n);}```
```
ToggleNthBit(1, 5); 
/*
  00000001
| 00010000
-----------
  00010001
*/
ToggleNthBit(1, 5); 
/*
  00010001
| 00010000
-----------
  00000001
*/
```
#### 4. ~ NOT 運算
NOT 即是相反事件，當 a = 1，則 ~a = 0；當 a = 0，則 ~a = 1。此性質搭配 AND 可將某變數的第 n 的位元設成 0 ```void ClearNthBit(unsigned int x, int n) {x &= ~(1 << n);}```\
若是要將某一區段的位元設為 1，則可另外設個變數與該變數做 NOT 和 AND 運算 
```C
unsigned char x = 127, n = 7;  //   n = 0x00000111
x &= ~(n << 3);  將 x 的第 4~6 為設成 0
/*
  7 << 3 = 00111000 --> ~(00111000) = 11000111
  01111111
| 11000111
-----------
  01000111
*/
```
在一些儀控的產品裡面，因為記憶體不多，所以常會使用某塊記憶體中的某個位元來當作開關。
## 4. 位元運算應用
#### 1. 加法
因為在二進位的世界只有 0 與 1，所以在二進位的世界中，01<sub>2</sub> + 01<sub>2</sub> = 10<sub>2</sub>，00<sub>2</sub> + 00<sub>2</sub> = 00<sub>2</sub>，01<sub>2</sub> + 00<sub>2</sub> = 01<sub>2</sub>，01<sub>2</sub> + 00<sub>2</sub> = 01<sub>2</sub>。所以可知加法運算中，第一位對應到的運算為 XOR 運算，再來當需要進位的情況就是當同位數字皆為 1 時，即為 AND 運算，然後再左移 1 bit，故整段 code 為
```C
int bitAdd(int a, int b)
{
    while (b != 0) 
    {
        unsigned int x = (unsigned int)a ^ (unsigned int)b;
        unsigned int y = ((unsigned int)a & (unsigned int)b) << 1; 
        a = x;
        b = y;
    }
    return a;
}
```
此算法在不溢位的情況下，a、b 為負數也能正確計算。

#### 2. 取餘數
已知 a 對 b 取餘數的結果為 r ，且 **b ∈ 2<sup>n</sup>**，n ∈ Z+，寫作 a%b，則有以下關係：a = b* q + r，其中 a 為被除數，b 為除數，q 為商數，r 為餘數，r < b。舉例來說，11 對 3 取餘數為 2，則 11 = 3* 3 + 2。當我們使用二進位來看時\
...11 = 1011\
% 3 = 0011\
一一一一一一一\
.....2 = 0010\
又 r < b，故只要將 a&(b-1) 就能得到 a%b。\
註：若是要利用此方法來判斷餘數為多少時執行的敘述記得要加括號，因為 & 的優先序低於 == ```if((n&7) == 5)```。

#### 3. 交換兩數
在先前我們知道要將兩數傳入某函數後交換其數值的方式，在此我們也可以用位元運算來達成此結果。有兩數 a，b。若要將 a 的數值經由位元運算變成 b 且不另外宣告新的變數，先從數學上來看\
a = a - b = a + (-b)\
b = b + a = b + a - b = a\
a = a - b = a + (-b)\
所以實際上可以使用位元運算的加法來達成此目的，然而在這邊我們就不需要考慮進位的問題。
```C
void swap(int *a, int *b)
{
    *a = *a ^ *b;
    *b = *b ^ *a;
    *a = *a ^ *b;
}
```
若是整數的變數交換，可使用位元運算的方式。而若是浮點數運算，當兩數差異很大時會有捨入誤差，故這兩種做法雖然是 in-place 的方法，但仍有其限制存在。

#### 4. 計算某數有幾個 bit 為 1
已知對於任意二進位整數 n，n > 0，至少有 1 個 bit 為 1，先考慮 n = 8 = 2<sup>3</sup> = 1000<sub>2</sub>，當我們取 n & (n-1) 可得 (1000<sub>2</sub>) & (0111<sub>2</sub>) = 0，所以可知對於 n = 2<sup>k</sup> 可這樣做。而對於 n =/= 2<sup>k</sup> 時，設 n = 9 = 1001<sub>2</sub>，則 n & (n-1) = (1001<sub>2</sub>) & (1000<sub>2</sub>) = 1000<sub>2</sub>，最後一步都會到 n = 2<sup>k</sup> 的例子，故可知此算法可行。
```C
int bitcount(unsigned int n)
{
   int count = 0 ;
   while (n)
   {
      count++ ;
      n = n&(n - 1);
   }
   return count ;
}
```
